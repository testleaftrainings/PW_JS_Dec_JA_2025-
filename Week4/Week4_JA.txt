Q1. Explain the use of "?" (optional parameter) 

Ans: The ? (Optional Parameter / Property)
 “This value is optional — you can give it or skip it.”
 It helps your program not break even when the value is missing.

✅ Example: Optional Function Parameter
function greet(name?: string) {
  if (name) {
    console.log(`Hello, ${name}!`);
  } else {
    console.log("Hello, Guest!");
  }
}

greet("World"); // Hello, World!
greet();            // Hello, Guest!


The ? after a parameter makes it optional — no error even if you don’t pass that argument.
Without ?, the argument is required and calling the function without it will throw an error//❌ Error – Argument required.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Q2. What is Type Alias?

A Type Alias in TypeScript is a way to create your own custom type with a name, so you can reuse it anywhere in your code.
It makes complex types simple, readable, and reusable


Syntax:
------

type User = {             //User is a Type Alias (or simply a custom type), It defines the shape/structure of the object.
  name: string;
  age: number;
};

let person: User = {    //They are variables/objects created using the User type.
  name: "Gauthami",
  age: 25
};


User → Type Alias (blueprint)
person1 / person2 → Objects (built using that blueprint)

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Q3. What is a union type and how do you use it?

ANS: A Union Type allows a variable to hold more than one type of value.
Instead of restricting a variable to a single type, you can say:

“This variable can be of Type A or Type B.”
It’s written using the pipe symbol |.

syntax:
-------

let variable: string | number;
Here, variable can be either a string or a number.

EX1: let id: string | number;

id = 101;      // ✅ number is allowed
id = "101AB";  // ✅ string is allowed
// id = true;  ❌ ❌ boolean is NOT allowed

Here, id can accept both numbers and strings.


Flexibility – You can allow multiple types without breaking type safety.
Safer code – TypeScript will still check valid operations for each type.
Common in real-world code – Especially with APIs, forms, or optional values.


Real-Time Example: User Input
-------------------------------

Imagine you have a login system where a user can enter either their username (string) or user ID (number) to log in.

type UserInput = string | number;

function login(input: UserInput) {
    if (typeof input === "string") {
        console.log(`Logging in with username: ${input}`);
    } else {
        console.log(`Logging in with user ID: ${input}`);
    }
}

login("gauthami123"); // Logging in with username: gauthami123
login(1024);          // Logging in with user ID: 1024


✅ Why this is useful:

The function can handle different kinds of input without creating separate functions.
Union type makes the code flexible and type-safe.
------------------------------------------------------------------------------------------------------------------------------------------------------------------
Q4.What is intersection type and how do you use it?

An Intersection Type combines multiple types into one.
A variable or object must satisfy all the types at the same time.

It’s written using the '&' symbol.

Syntax:
1) type A = { name: string };
type B = { age: number };

type Person = A & B; // Intersection
Person must have both name (string) and age (number).

let person:Person={
    name: "Sujeevan",
    age: 30
}

// to print the object
console.log(person);   //Sujeevan, 30

---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Q5. what is the difference between `any` and `unknown`?

Ans: these are the dataTypes available in Typescript

1) any

Definition: any allows any type of value.
TypeScript stops checking type safety for that variable.

let value: any;

value = 10;
value = "Hello";
value = true;

console.log(value); // ✅ Works, TypeScript allows everything

Pros: Very flexible
Cons: No type safety → can lead to runtime errors

2) unknown

Definition:unknown also allows any type, but TypeScript forces you to check the type before using it.
Safer than any.

EX:
let value: unknown;

value = 10;
value = "Hello";

// console.log(value.toUpperCase()); // ❌ Error: Object is of type 'unknown'

// Type check needed
if (typeof value === "string") {
  console.log(value.toUpperCase()); // ✅ Works
}

Pros: Flexible and type-safe
Cons: Need to do type checks before using

------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Q6. What are alerts and How do you handle simple, confirmation and prompt alerts in Playwright?

In web applications, alerts are pop-up dialog boxes that appear on the browser to get user attention or input.

a) Modal alerts(not inspectable)
--------------------------------

1) simple-ok
2) confirmation-ok and cancel
3) prompt-ok, cancel and input textbox


b) Non modal alerts

1) Sweet-dismiss(inspectabe)
----------------------------

Playwright provides the page.on('dialog') event to handle any type of dialog.

syntax:

 page.on('dialog', async (dialog) => {
  console.log(dialog.message()); // prints alert message
  await dialog.accept();         // clicks OK
  // or await dialog.dismiss();  // clicks Cancel
});

--------------------------------------------------------------------------------------------------------------------------------------------------------------------
Q7. what is the difference between page.on and page.once?

Page.on:
--------
page.on('dialog', callback)
The callback will run every time a dialog appears, whether it’s a simple alert, confirmation, or prompt.
So if your page triggers 3 alerts one after another, the callback executes 3 times, once for each alert.

Syntax: 
-------
page.on('dialog', async dialog => {
console.log('Dialog type:', dialog.type()); // alert, confirm, or prompt
await dialog.dismiss(); // dismiss all dialogs
});


page.once:
----------

page.once('dialog', callback)
The callback will run only for the first dialog that appears, regardless of type.
After handling that first alert, it automatically stops listening.

Syntax:
-------
page.once('dialog', async dialog => {
    console.log('First dialog type:', dialog.type());
    await dialog.accept(); // only handles the first dialog
});
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
Q8. what are frames and how do you interact with frames?

1) In a web page, a frame is basically an embedded HTML document inside another HTML document. There are two common types:

<iframe> (inline frame)
Most common type of frame.
It loads another webpage or content inside the main page.
<frame> / <frameset> (old, less common)
Used in legacy websites, not recommended today.

Syntax:

page.frames()-> frames() method helps to get the collection of frames that is present in a webpage.
page.frameLocator(selector) → Locates elements inside a frame (recommended).
page.frame({ name | url | index }) → Gets the frame object to interact with.

In playwright, main page is also considered as frame and index starts from '0'

2) Why frames matters in automation

Since frames have their own DOM, normal page locators like page.locator() won’t work directly inside a frame.
You need to switch context to the frame to interact with its elements.

3) How to interact with frames in Playwright

we can interact with frames using 

a)By name or ID
const frame = page.frame({ name: 'myFrame' });


b) By URL
const frame = page.frame({ url: /example.com/ });


e) By element handle

const frameElement = await page.locator('#myFrame');
const frame = await frameElement.frame();

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

Q9. What is the difference between `page.frame()` and `frameLocator()`?


page.frame()
------------
Returns a Frame object, representing a specific <iframe> inside the page.

Definition:
const frame = page.frame({ name: 'iframe-name' });


Parameters:
name: Name of the iframe
url: URL of the iframe (can use regex)
Or any other frame identification

Usage: You can then call methods like fill(), click(), locator() on the frame object.

Example:

const frame = page.frame({ name: 'myFrame' });
if (frame) {
  await frame.fill('#username', 'JohnDoe');
  await frame.click('button[type="submit"]');
}

page.frameLocator()
-------------------
Returns a FrameLocator object, which allows locator-based interaction inside a frame.

Definition:
const frameLocator = page.frameLocator('#iframe-selector');

You can chain locators to interact with elements inside the iframe. Works well for nested frames.

Example:

const frameLocator = page.frameLocator('#myFrame');
await frameLocator.locator('#username').fill('JohnDoe');
await frameLocator.locator('button[type="submit"]').click();
s
------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q10: How do you handle windows in playwright?

Window Handling
-------------

Window Handling is Managing/ Switching between multiple page objects (new tabs or browser windows) opened by the application within the same browser context.

Types:

Sequential Approach
-------------------
Sequential approach means handling multiple browser windows or tabs one after another in the order they open, by waiting for each new Page object and performing 
actions step-by-step.

const newPage = context.waitForEvent('page') // Pending  // Step 1 : Listener open
await page.locator(`//div[contains(text(),"MOTOROLA g35 5G")]`).click();  // Step 2 : Click action/Click Event
const childPage =   await newPage  // Step3 : Resolving the promise //The page is captured by this time// Promise is resolved ones playwright has captured the newPage
that got launched

Note: Simpler but may risk of missing the event if the page opens too quickly.
----


Concurrent Approach (Recommended)
-------------------

Concurrent approach in Playwright uses Promise.all() to wait for the popup and the triggering action simultaneously, ensuring reliable window handling without race 
conditions.


const [newPage] = await Promise.all([
  context.waitForEvent('page'),
  actionThatOpensNewPage()
]);

const [childPage] = await Promise.all([context.waitForEvent('page'),page.locator(`//div[text()="POCO C71 (Desert Gold, 64 GB)"]`).click()])

**Ensures you never miss the page event.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q11. How do you close a child window and return to the parent?

Switch between pages using:
--------------------------

context.pages();       // Returns all open pages in the context
newPage.bringToFront(); // Focus a specific page

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
Q12. How does Playwright handle file downloads?


# File Download
----------------

Handling files downloaded by the application (clicking "Download" links/buttons).

### **Usage**

Playwright provides a `page.waitForEvent('download')` listener.


// using promise.all along with event listener
----------------------------------------------

const [download] = await Promise.all([
  page.waitForEvent('download'),      // Wait for download event
  page.click('text=Download Report')  // Trigger download
]);

// Save to desired path
------------------------

await download.saveAs('downloads/report.pdf');

// Get file path in temp location
---------------------------------

console.log(await download.path());

-------------------------------------------------------------------------------------

//Using Event Listener
-----------------------
await page.goto('https://leafground.com/file.xhtml')  

const filePromise=page.waitForEvent("download")  

await page.getByText('Download',{exact:true}).click()

const fDown=await filePromise //resolve the promise, once download action is completed

//option 1- download and store in created folder
------------------------------------------------

await fDown.saveAs("Data/sepPW.png")//setting the Path to download a file and save it

await page.waitForTimeout(2000)

await fDown.saveAs(fDown.suggestedFilename())//save under root directory with suggested filename

await fDown.saveAs(`Data/${fDown.suggestedFilename()}`)//save under data folder with suggested filename

//option 2-using absolute path
-------------------------------

await fDown.saveAs(path.join(__dirname,'../Data/',fDown.suggestedFilename()))    //original filename

    
//option 3-store in local machine
---------------------------------

await fDown.saveAs('C:/Users/admin/OneDrive - TestLeaf Software Solutions Private Limited/Documents/filedownload')
await page.waitForTimeout(2000)
})


* Default: Playwright saves downloads in a temporary directory.
* Always use `Promise.all` to avoid missing the download event.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q13. How can you verify the downloaded file name?

Compare expected vs received filename.

const expectedText = "report.pdf";
const receivedText = downloader.suggestedFilename();

expect(expectedText).toBe(receivedText);
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q14. How to automate file uploads using Playwright?

Case 1: With <input type="file">

await page.locator('input#fileUpload').setInputFiles("./Data/report.pdf");


Case 2: Without <input type="file"> (using FileChooser)

const fileUploader = page.waitForEvent("filechooser"); // promise and event listener
await page.locator('#uploadButton').click(); // trigger file chooser
(await fileUploader).setFiles("./Data/logindata.json");

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q15. Can you upload multiple files?

Yes, if <input type="file" multiple /> is present.

const fileUploader = page.waitForEvent("filechooser");
await page.locator('#uploadButton').click();
(await fileUploader).setFiles(["./Data/logindata1.json", "./Data/logindata2.json"])
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q16. What is `storageState` in Playwright?

Each Playwright test runs in a fresh browser context, so if the login session is lost and you must log in again for every test. 
Using storageState this problem can be bypassed by saving the login state (such as cookies and tokens) into a JSON file and loading that file in future tests to skip the login steps.

Step 1: Save login state after login
import { test, expect } from '@playwright/test';

test('Login and save storage state', async ({ page }) => {
  await page.goto('https://example.com/login');
  await page.fill('#username', 'admin');
  await page.fill('#password', 'Admin@123');
  await page.click('button[type="submit"]');

  // Save session to a file
  await page.context().storageState({ path: 'auth.json' });
});


This will create a file named auth.json containing cookies and local storage data.


use the below test.use prpoerty in spec.ts to skip the Login
-------------------------------------------------------------

test.use({

storageState: 'path: 'auth.json'
})
------------------------------------------------------------------------------------------------------------------------------------------------------------------------